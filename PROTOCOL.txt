PROTOCOL:
Let S be a sequencer, let C be a client, and let A be all. 

Register:
When client enters the chat for the first time,
C->S reg:name
S retrives address (ip/port) from recvfrom
S multicasts notice to everybody except C
S->A msg:NOTICE name joined on ip:port
S adds C's address and name to address list
S->C reg:clientip:clientport:userlist
C prints joining info, followed by current user list
Done

Message:
C->S msg:Message
S gets name by client's address, and extracts Message
S->A msg:name:: Message

Update the list of clients (no leader info):
When client enters the chat and wants to register,
S->A upd:name1:ip1:port1:name2:ip2:port2:...:end
Each client updates their client list

Update leader info
S->A udl:name

Requrements
-User can start a new chat group
-User can join an existing chat group (via sequencer)
-User can join by connecting to any member of a the group they want to join
-Sequencer/Client can leave the group (is-alive mechanism)
-Leader election & Leader switch from client
-Leader/client have an up to date list of those currently in the chat
-Use get messages via multicast by sequencer
-fully ordered multicast protocol (based on a sequencer) via message queue
-Deal with lost/duplicate messages (both of message delivery and of other clients)
-Deal with clients that crash and/or leave
-Exit the chat gracefully by indicating EOF on stdin (control-D)
